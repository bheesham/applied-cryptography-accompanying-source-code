.\" @(#)EG.3bm 91/12/13;
.EQ
delim $$
.EN
.TH "EL GAMAL" 3BM
.SH NAME
genEGParams, genEGKeySet, EGEncrypt, EGDecrypt, EGSign, EGVerify
freeEGKeys, freeEGSig, freeEGParams, freeEGPublicKey, freeEGPrivateKey
randBytesNeededForEGParams, randBytesNeededForEGKeySet
randBytesNeededForEGEncrypt, randBytesNeededForEGSign

.SH SYNOPSIS
.nf
\fB#include <libcrypt.h>\fR
.LP
\fBint randBytesNeededForEGParams(int pbits, int qbits);\fR
.LP
\fBint randBytesNeededForEGKeySet(int qbits);\fR
.LP
\fBint randBytesNeededForEGEncrypt(int qbits);\fR
.LP
\fBint randBytesNeededForEGSign(int qbits);\fR
.LP
\fBEGParams *genEGParams(int numbits_in_p, int numbits_in_q, BigInt randomStart)\fR
.LP
\fBEGKeySet *genEGKeySet(EGParams *params, int pbits, int qbits, BigInt randomStart)\fR
.LP
\fBBigInt EGEncrypt(BigInt m, EGPublicKey *key, BigInt randomStart)\fR
.LP
\fBBigInt EGDecrypt(BigInt encryptedMessage, EGPrivateKey *key)\fR
.LP
\fBBigInt quantized_EGDecrypt(BigInt encryptedMessage, EGPrivateKey *key)\fR
.LP
\fBEGSignature *EGSign(BigInt m, EGPrivateKey *key, BigInt randomStart)\fR
.LP
\fBEGSignature *quantized_EGSign(BigInt m, EGPrivateKey *key)\fR
.LP
\fBBoolean EGVerify(BigInt m, EGSignature *sig, EGPublicKey *key)\fR
.LP
\fBvoid freeEGKeys(EGKeySet *keyset)\fR
.LP
\fBvoid freeEGPublicKey(EGPublicKey *key)\fR
.LP
\fBvoid freeEGPrivateKey(EGPrivateKey *key)\fR
.LP
\fBvoid freeEGSig(EGSignature *sig)\fR
.fi
.SH DESCRIPTION
.LP
For all of these functions $BigInt$ arguments are assumed to be initialized
$BigInts$.  $bigInit(0)$ should be used for initialization of
empty $BigInts$.  If more space is needed than is provided the
functions themselves take care of the space allocation.

In all of the function which have an argument, $randomStart$, if this argument
is chosen NULL, the default, DES-based pseudo-RNG seeded with truerand() will
be used to generate necessary random material.  If $randomStart$ is not
NULL, the accompanying functions, \fIrandBytesNeededForEG...\fR are
used to find out how many random bytes are expected.

El Gamal cryptosystems may use a different random prime $p$, a primitive root
$alpha (mod~ p)$ and a secret $X sub size +2 a$ for each user.
If genEGParams() is called before creating keys the Params may be used
to ensure that all (or a group of) users share the same parameters.
If $genEGKeySet()$ is called with params = NULL, a new set of parameters will
be created for each key set.
A user's public key is $Y sub size +2 a = alpha sup size +2 {X sub size +2 a} mod ~p$.  To encrypt a message $m$, one creates a key
$K = Y sub size +2 b sup {X sub size +2 a} mod~ p$.  The encrypted
message is then represented as the pair $(Y sub size +2 a , K*m ~mod~p)$  A recipient of the pair can then regenerate the key as
$K = Y sub size +2 a sup {X sub size +2 b} mod ~p$ and then divide
the second part of the received pair by $K$ to get $m$.

$genEGParams$ generates the prime $p$ and the primitive root
$alpha$ and returns them in an $EGParams$ structure.
It takes as argument the desired length of $p$ in bits.

$genEGKeySet$ generates the public and private keys for
El Gamal systems.  The private key differs from the public key
in that the secret $X sub size +2 a$ is included.  This function
takes the an $EGParams$ structure pointer as generated by
$genEGParams$ as argument.

$getEGPublicKey$ and $getEGPrivateKey$ take an $EGKeySet$ structure pointer as an argument and return the public or private
key.

If the thing being signed or encrypted is smaller than q, the large prime factor
of p-1, the El Gamal functions will use Brickell's modular exponentiation
enhancement whereever possible.

$EGEncrypt$ encrypts a $BigInt message$ using a $public key$ and
returns an $EGEncryptedMessage$ structure which is the pair
of $BigInts$ discussed above.

$EGDecrypt$ takes the pair generated by $EGEncrypt$ and
and the private key associated with the public key used for encryption
and returns the original $BigInt message$.  The quantized version
use STD_QUANTUM milliseconds as the quantum for execution to defend against
Kocher-style timing attacks.  (The same is true of quantized_EGSign).
STD_QUANTUM is defined in libcrypt.h and should be tuned to your environment.

$EGSign$ generates a digital signature for message $m$ using
a private key.

$EGVerify$ verifies that a signature received with a message $m$
is valid using the public key which corresponds to the private key
used to generate the signature.

$DSSSign and DSSVerify$ are much more efficient and use the same keys as
the El Gamal counterparts.  The signature is also shorter.

$free*$ free their respective structures.
.fi
.SH "SEE ALSO"
.BR bigInit (3BM),
.BR bigTest (3BM),
.BR bigBits (3BM),
.BR bigBytes (3BM),
.BR bigToBuf (3BM),
.BR bufToBig (3BM),
.BR fBigPrint (3BM),
.BR atobig (3BM),
.BR bigPow (3BM)
.BR start_quantize (3BM)
.BR end_quantize (3BM)
