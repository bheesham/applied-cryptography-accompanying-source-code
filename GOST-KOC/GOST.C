From Mercury!leland.Stanford.EDU!kocherp Fri Sep 16 03:42:37 1994
Return-Path: <Mercury!leland.Stanford.EDU!kocherp>
Received: by chinet (/\==/\ Smail3.1.28.1 #28.1{chinet})
	id <m0qlYsO-0002GLC@chinet>; Fri, 16 Sep 94 03:42 CDT
Received: by mercury.mcs.com (/\==/\ Smail3.1.28.1 #28.1)
	id <m0qlYQi-000BZxC@mercury.mcs.com>; Fri, 16 Sep 94 03:14 CDT
Received: (kocherp@localhost) by cardinal.Stanford.EDU (8.6.8/8.6.4) id BAA05811; Fri, 16 Sep 1994 01:13:41 -0700
Date: Fri, 16 Sep 1994 01:13:41 -0700
From: Paul Carl Kocher <kocherp@leland.Stanford.EDU>
Message-Id: <199409160813.BAA05811@cardinal.Stanford.EDU>
To: crypto@isl.Stanford.EDU, schneier@chinet.chi.il.us
Subject: GOST sample code with actual S boxes
Status: RO



Hello --

I just reverse-engineered GOST implementation in the program 
called "Excellence" that was sent to me by Bruce Schneier, and 
have found that the S boxes (e.g. the eight 4-bit to 4-bit 
conversions) are implemented by the program in a way that 
deviates from what is specified in translated version I have of 
the algorithm definition. 

In particular, the program optimizes the lookups by doing two 
at a time, using four 256-byte lookup tables.  However the left 
and input nibbles of each byte don't uniquely specify the left 
and right output nibbles of each byte.  (E.g. what the left 
four bits of the input byte get translated to can depend on 
what the right hand four bits equal.)  Also, some of the tables 
also contain quite a few zeros at the end, which seems to me as 
though it may weaken the security (hopefully someone who knows 
the algorithm better than I do can comment on the implications
of using these tables). 

I was quite surprised that the implementation is so odd, so I 
tossed together a sloppy implementation to test everything and 
found that my code was indeed compatible with Excellence.  A 
copy of the code including the S lookup tables is attached.  
I've hard-wired the program with the -e0 (encrypt to self) key, 
but the S boxes are the same with the -e1 key (and presumably 
all other keys).  Note that the program calls PKZIP to compress 
the input files before encrypting them, so if you use my 
program to decrypt a file, you should get a PKZIP archive, 
which you can then decompress with PKUNZIP. 

Cheers,
Paul Kocher
kocherp@leland.stanford.edu



/* Copyright 1994 Paul Kocher (kocherp@leland.stanford.edu).
 * Please ask for permission before distributing widely.
 *
 * GOST.C:  Quick and dirty implementation of the GOST encryption standard from
 *          the U.S.S.R.  Uses S boxes from the Soviet program "Excellence."
 *
 * Note:  The S boxes used (see the tables K12/K34/K56/K78) don't satisfy the
 *        GOST standard, since they are supposed to transform 4-bit inputs to
 *        4 bit outputs.  Instead they transform 8-bit inputs to 8-bit outputs,
 *        and the two halves of the operation can't be separated.
 *
 * The main() function in this program will retrieve the initialization vector 
 * from the end of an encrypted archive and will use it to decrypt the data.  
 * The output file should be a PKZIP archive.  The 32-byte key in the main() 
 * function is the key used by the -e0 (encrypt for self) option in Excellence.
 * If a different key is selected, the same nonstandard S boxes are still used.
 */
 
#include <stdio.h>

#define SWAP(a,b) a^=b^=a^=b;

typedef struct {
  unsigned long X[8];           /* the key (KMU) */
  unsigned char lastBlock[8];   /* for CBC chaining */
} GOST_CTX;
#define OPERATION_ENCRYPT 1
#define OPERATION_DECRYPT 0

unsigned char K12[256] = { 0xD0,0xCF,0xCE,0xCD,0xCC,0xCB,0xCA,0xC9,
                           0xC8,0xC7,0xC6,0xC5,0xC4,0xC3,0xC2,0xC1,
                           0xC0,0xBF,0xBE,0xBD,0xBC,0xBB,0xBA,0xB9,
                           0xB8,0xB7,0xB6,0xB5,0xB4,0xB3,0xB2,0xB1,
                           0xB0,0xAF,0xAE,0xAD,0xAC,0xAB,0xAA,0xA9,
                           0xA8,0xA7,0xA6,0xA5,0xA4,0xA3,0xA2,0xA1,
                           0xA0,0x9F,0x9E,0x9D,0x9C,0x9B,0x9A,0x99,
                           0x98,0x97,0x96,0x95,0x94,0x93,0x92,0x91,
                           0x90,0x8F,0x8E,0x8D,0x8C,0x8B,0x8A,0x89,
                           0x88,0x87,0x86,0x85,0x84,0x83,0x82,0x81,
                           0x80,0x7F,0x7E,0x7D,0x7C,0x7B,0x7A,0x79,
                           0x78,0x77,0x76,0x75,0x74,0x73,0x72,0x71,
                           0x70,0x6F,0x6E,0x6D,0x6C,0x6B,0x6A,0x69,
                           0x68,0x67,0x66,0x65,0x64,0x63,0x62,0x61,
                           0x60,0x5F,0x5E,0x5D,0x5C,0x5B,0x46,0x47,
                           0x48,0x49,0x4A,0x4B,0x4C,0x4D,0x4E,0x4F,
                           0x50,0x51,0x52,0x53,0x54,0x55,0x56,0x57,
                           0x58,0x59,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };

unsigned char K34[256] = { 0x8C,0x8B,0x8A,0x89,0x88,0x87,0x86,0x85,
                           0x84,0x83,0x82,0x81,0x80,0x7F,0x7E,0x7D,
                           0x7C,0x7B,0x7A,0x79,0x78,0x77,0x76,0x75,
                           0x74,0x73,0x72,0x71,0x70,0x6F,0x6E,0x6D,
                           0x6C,0x6B,0x6A,0x69,0x68,0x67,0x66,0x65,
                           0x64,0x63,0x62,0x61,0x60,0x5F,0x5E,0x5D,
                           0x5C,0x5B,0x5A,0x59,0x58,0x57,0x56,0x55,
                           0x54,0x53,0x52,0x51,0x50,0x4F,0x4E,0x4D,
                           0x4C,0x4B,0x4A,0x49,0x48,0x47,0x46,0x45,
                           0x44,0x43,0x42,0x41,0x40,0x3F,0x3E,0x3D,
                           0x3C,0x3B,0x3A,0x39,0x38,0x37,0x36,0x35,
                           0x34,0x33,0x32,0x31,0x30,0x2F,0x2E,0x2D,
                           0x2C,0x2B,0x2A,0x29,0x28,0x27,0x26,0x25,
                           0x24,0x23,0x22,0x21,0x20,0x1F,0x1E,0x1D,
                           0x1C,0x1B,0x1A,0x19,0x18,0x17,0x16,0x15,
                           0x14,0x13,0x12,0x11,0x10,0x0F,0x0E,0x0D,
                           0x0C,0x0B,0x0A,0x09,0x08,0x07,0x06,0x05,
                           0x04,0x03,0x02,0x01,0x00,0xFF,0xFE,0xFD,
                           0xFC,0xFB,0xFA,0xF9,0xF8,0xF7,0xF6,0xF5,
                           0xF4,0xF3,0xF2,0xF1,0xF0,0xEF,0xEE,0xED,
                           0xEC,0xEB,0xEA,0xE9,0xE8,0xE7,0xE6,0xE5,
                           0xE4,0xE3,0xE2,0xE1,0xE0,0xDF,0xDE,0xDD,
                           0xDC,0xDB,0xDA,0xD9,0xD8,0xD7,0xD6,0xD5,
                           0xD4,0xD3,0xD2,0xD1,0xD0,0xCF,0xCE,0xCD,
                           0xCC,0xCB,0xCA,0xC9,0xC8,0xC7,0xC6,0xC5,
                           0xC4,0xC3,0xC2,0xC1,0xC0,0xBF,0xBE,0xBD,
                           0xBC,0xBB,0xBA,0xB9,0xB8,0xB7,0xB6,0xB5,
                           0xB4,0xB3,0xB2,0xB1,0xB0,0xAF,0xAE,0xAD,
                           0xAC,0xAB,0xAA,0xA9,0xA8,0xA7,0xA6,0xA5,
                           0xA4,0xA3,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };

unsigned char K56[256] = { 0x78,0x77,0x76,0x75,0x74,0x73,0x72,0x71,
                           0x70,0x6F,0x6E,0x6D,0x6C,0x6B,0x6A,0x69,
                           0x68,0x67,0x66,0x65,0x64,0x63,0x62,0x61,
                           0x60,0x5F,0x5E,0x5D,0x5C,0x5B,0x5A,0x59,
                           0x58,0x57,0x56,0x55,0x54,0x53,0x52,0x51,
                           0x50,0x4F,0x4E,0x4D,0x4C,0x4B,0x4A,0x49,
                           0x48,0x47,0x46,0x45,0x44,0x43,0x42,0x41,
                           0x40,0x3F,0x3E,0x3D,0x3C,0x3B,0x3A,0x39,
                           0x38,0x37,0x36,0x35,0x34,0x33,0x32,0x31,
                           0x30,0x2F,0x2E,0x2D,0x2C,0x2B,0x2A,0x29,
                           0x28,0x27,0x26,0x25,0x24,0x23,0x22,0x21,
                           0x20,0x1F,0x1E,0x1D,0x1C,0x1B,0x1A,0x19,
                           0x18,0x17,0x16,0x15,0x14,0x13,0x12,0x11,
                           0x10,0x0F,0x0E,0x0D,0x0C,0x0B,0x0A,0x09,
                           0x08,0x07,0x06,0x05,0x04,0x03,0x02,0x01,
                           0x00,0xFF,0xFE,0xFD,0xFC,0xFB,0xFA,0xF9,
                           0xF8,0xF7,0xF6,0xF5,0xF4,0xF3,0xF2,0xF1,
                           0xF0,0xEF,0xEE,0xED,0xEC,0xEB,0xEA,0xE9,
                           0xE8,0xE7,0xE6,0xE5,0xE4,0xE3,0xE2,0xE1,
                           0xE0,0xDF,0xDE,0xDD,0xDC,0xDB,0xDA,0xD9,
                           0xD8,0xD7,0xD6,0xD5,0xD4,0xD3,0xD2,0xD1,
                           0xD0,0xCF,0xCE,0xCD,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };

unsigned char K78[256] = { 0x9E,0x9D,0x9C,0x9B,0x9A,0x99,0x98,0x97,
                           0x96,0x95,0x94,0x93,0x92,0x91,0x90,0x8F,
                           0x8E,0x8D,0x8C,0x8B,0x8A,0x89,0x88,0x87,
                           0x86,0x85,0x84,0x83,0x82,0x81,0x80,0x7F,
                           0x7E,0x7D,0x7C,0x7B,0x7A,0x79,0x78,0x77,
                           0x76,0x75,0x74,0x73,0x72,0x71,0x70,0x6F,
                           0x6E,0x6D,0x6C,0x6B,0x6A,0x69,0x68,0x67,
                           0x66,0x65,0x64,0x63,0x62,0x61,0x60,0x5F,
                           0x5E,0x5D,0x5C,0x5B,0x5A,0x59,0x58,0x57,
                           0x56,0x55,0x54,0x53,0x52,0x51,0x50,0x4F,
                           0x4E,0x4D,0x4C,0x4B,0x4A,0x49,0x48,0x47,
                           0x46,0x45,0x44,0x43,0x42,0x41,0x40,0x3F,
                           0x3E,0x3D,0x3C,0x3B,0x3A,0x39,0x38,0x37,
                           0x36,0x35,0x34,0x33,0x32,0x31,0x30,0x2F,
                           0x2E,0x2D,0x2C,0x2B,0x2A,0x29,0x28,0x27,
                           0x26,0x25,0x24,0x23,0x22,0x21,0x20,0x1F,
                           0x1E,0x1D,0x1C,0x1B,0x1A,0x19,0x18,0x17,
                           0x16,0x15,0x14,0x13,0x12,0x11,0x10,0x0F,
                           0x0E,0x0D,0x0C,0x0B,0x0A,0x09,0x08,0x07,
                           0x06,0x05,0x04,0x03,0x02,0x01,0x00,0xFF,
                           0xFE,0xFD,0xFC,0xFB,0xFA,0xF9,0xF8,0xF7,
                           0xF6,0xF5,0xF4,0xF3,0xF2,0xF1,0xF0,0xEF,
                           0xEE,0xED,0xEC,0xEB,0xEA,0xE9,0xE8,0xE7,
                           0xE6,0xE5,0xE4,0xE3,0xE2,0xE1,0xE0,0xDF,
                           0xDE,0xDD,0xDC,0xDB,0xDA,0xD9,0xD8,0xD7,
                           0xD6,0xD5,0xD4,0xD3,0xD2,0xD1,0xD0,0xCF,
                           0xCE,0xCD,0xCC,0xCB,0xCA,0xC9,0xC8,0xC7,
                           0xC6,0xC5,0xC4,0xC3,0xC2,0xC1,0xC0,0xBF,
                           0xBE,0xBD,0xBC,0xBB,0xBA,0xB9,0xB8,0xB7,
                           0xB6,0xB5,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                           0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00 };

void GOST_Init(GOST_CTX *ctx, unsigned char key[32], unsigned char iv[8]);
void GOST_EncryptECB(GOST_CTX *ctx, unsigned char block[8]);
void GOST_DecryptECB(GOST_CTX *ctx, unsigned char block[8]);
void GOST_EncryptCBC(GOST_CTX *ctx, unsigned char block[8]);
void GOST_DecryptCBC(GOST_CTX *ctx, unsigned char block[8]);
void GOST_CryptCFB(GOST_CTX *ctx, unsigned char block[8]);
void GOST_RawCrypt(unsigned long *X, unsigned char *block, int operation);

void main(int argc, char **argv) {
  FILE *infile, *outfile;
  unsigned char block[8] = {0,0,0,0,0,0,0,0};
  GOST_CTX ctx;
  unsigned char key[32] = { 0x4B,0x9E,0xA4,0xD1,0x1A,0x32,0x17,0xD2,0xF3,0xB1,0xBD,0x9C,0xE9,0x89,0xB4,0x64,0x63,0xAA,0xE5,0x9A,0x26,0x68,0xB5,0x18,0x4A,0xC2,0xBE,0x79,0x71,0x24,0x54,0xAD };
  int i;


  /* Run test vectors */
  GOST_Init(&ctx, key, block);        /* use block = all 0 for IV */
  GOST_EncryptECB(&ctx, block);
  GOST_DecryptECB(&ctx, block);
  block[0] = 0x68;
  block[1] = 0x53;
  block[2] = 0xcd;
  block[3] = 0x1d;
  block[4] = 0x54;
  block[5] = 0xc2;
  block[6] = 0xd8;
  block[7] = 0x7d;
  GOST_EncryptECB(&ctx, block);
  GOST_DecryptECB(&ctx, block);

  /* Open files */
  if (argc != 3) {
    printf("Usage: %s infile outfile\n", argv[0]);
    return;
  }
  if ((infile = fopen(argv[1], "rb")) == NULL)
    printf("Cannot open input file.\n");
  if ((outfile = fopen(argv[2], "wb")) == NULL)
    printf("Cannot open output file.\n");
  if (infile == NULL || outfile == NULL)
    return;

  /* Read the IV and initialize the context */
  fseek(infile, -22, SEEK_END);
  fread(block, 1, 8, infile);
  GOST_Init(&ctx, key, block);
  fseek(infile, 0, SEEK_SET);

  /* Read and decrypt blocks */
  while (!feof(infile)) {
    fread(block, 1, 8, infile);
    GOST_CryptCFB(&ctx, block);
    fwrite(block, 1, 8, outfile);
  }
  fclose(infile);
  fclose(outfile);
}

unsigned long uchar2ulong(unsigned char i[4]) {
    return ((((unsigned long)(i[0])) << 0)
          + (((unsigned long)(i[1])) << 8)
          + (((unsigned long)(i[2])) << 16)
          + (((unsigned long)(i[3])) << 24));
}


void GOST_Init(GOST_CTX *ctx, unsigned char key[32], unsigned char iv[8]) {
  int i;

  for (i = 0; i < 8; i++)
    ctx->X[i] = uchar2ulong(&key[i*4]);
  for (i = 0; i < 8; i++)
    ctx->lastBlock[i] = iv[i];
  printf("IV ="); for (i = 0; i < 8; i++) printf(" %02x",iv[i]); printf("\n");
}


void GOST_EncryptECB(GOST_CTX *ctx, unsigned char block[8]) {
  GOST_RawCrypt(ctx->X, block, OPERATION_ENCRYPT);
}

void GOST_DecryptECB(GOST_CTX *ctx, unsigned char block[8]) {
  GOST_RawCrypt(ctx->X, block, OPERATION_DECRYPT);
}

void GOST_EncryptCBC(GOST_CTX *ctx, unsigned char block[8]) {
  int n;

  for (n=0; n < 8; n++)
    block[n] ^= ctx->lastBlock[n];
  GOST_RawCrypt(ctx->X, block, OPERATION_DECRYPT);
  for (n=0; n < 8; n++)
    ctx->lastBlock[n] = block[n];
}

void GOST_DecryptCBC(GOST_CTX *ctx, unsigned char block[8]) {
  int n;
  unsigned char temp[8];

  for (n=0; n < 8; n++)
    temp[n] = block[n];
  GOST_RawCrypt(ctx->X, block, OPERATION_DECRYPT);
  for (n=0; n < 8; n++)
    block[n] ^= ctx->lastBlock[n];
  for (n=0; n < 8; n++)
    ctx->lastBlock[n] = temp[n];
}

void GOST_CryptCFB(GOST_CTX *ctx, unsigned char block[8]) {
  int n;
  unsigned char temp[8];

  GOST_RawCrypt(ctx->X, ctx->lastBlock, OPERATION_ENCRYPT);
  for (n=0; n < 8; n++) {
    block[n] ^= ctx->lastBlock[n];
    ctx->lastBlock[n] ^= block[n];
  }
}



void GOST_RawCrypt(unsigned long *X, unsigned char *block, int operation) {
  unsigned long N1, N2, TMP1, TMP2;
  int round;

  N1 = uchar2ulong(block+0);
  N2 = uchar2ulong(block+4);

  round = (operation == OPERATION_ENCRYPT) ? 0 : 31;
  do {

    if (round < 24)
      TMP1 = N1 + X[round % 8];
    else
      TMP1 = N1 + X[31-round];

    TMP2  = ((unsigned long)(K12[(int)(TMP1 >>  0) & 0xFF])) <<  0;
    TMP2 |= ((unsigned long)(K34[(int)(TMP1 >>  8) & 0xFF])) <<  8;
    TMP2 |= ((unsigned long)(K56[(int)(TMP1 >> 16) & 0xFF])) << 16;
    TMP2 |= ((unsigned long)(K78[(int)(TMP1 >> 24) & 0xFF])) << 24;
    TMP2 = (TMP2 << 11) | (TMP2 >> 21);
    N2 ^= TMP2;
    N1 ^= N2 ^= N1 ^= N2;

    if (operation == OPERATION_ENCRYPT) round++; else round--;
  } while (round >= 0 && round < 32);

  block[0] = (N2 >>  0) & 0xFF;
  block[1] = (N2 >>  8) & 0xFF;
  block[2] = (N2 >> 16) & 0xFF;
  block[3] = (N2 >> 24) & 0xFF;
  block[4] = (N1 >>  0) & 0xFF;
  block[5] = (N1 >>  8) & 0xFF;
  block[6] = (N1 >> 16) & 0xFF;
  block[7] = (N1 >> 24) & 0xFF;
}


