/*
 * KEA (Key Exchange Algorithm) implementation
 * using the DH and Skipjack routines from Peter Gutmann's CryptLib
 * (and some pieces cribbed from various other parts of CryptLib)
 *
 * this version was written to interoperate with CryptLib 2.1beta
 * released January 18, 1999
 *
 * February 2, 1999
 */

#include <stdlib.h>
#include <string.h>
#include "crypt.h"
#include "cryptctx.h"

/* added for debugging */
#include <stdio.h>

/*
  III. ANNEX - Test Vectors
  [from skipjack-kea.tex,v 1.9 1998/07/10 11:17:15 cmcurtin
   in http://www.interhack.net/pubs/skipjack-kea.tgz]

  X represents ``don't-care''.

  B. Key Exchange Algorithm (KEA)

  */

/*
  1024-bit p

  DH over GF(p)

  */
const BYTE FAR_BSS primeTestKEA[] = { 0x9D, 0x4C, 0x6E, 0x6D, 0x42, 0xEA,
                                      0x91, 0xC8, 0x28, 0xD6, 0x7D, 0x49,
                                      0x94, 0xA9, 0xF0, 0x1B, 0x8E, 0x5B,
                                      0x5B, 0x73, 0x0D, 0x0F, 0xAA, 0xE7,
                                      0xBD, 0x56, 0x9D, 0xD1, 0x91, 0x4E,
                                      0x3A, 0xD4, 0x75, 0x9C, 0x80, 0x53,
                                      0x31, 0xED, 0xA1, 0x45, 0x9F, 0xB5,
                                      0x6B, 0xE8, 0xA8, 0xDE, 0x47, 0x36,
                                      0x65, 0x2A, 0x82, 0xB2, 0x76, 0xE8,
                                      0x2A, 0xCD, 0x63, 0xF5, 0xB7, 0x8D,
                                      0x0B, 0x75, 0xA0, 0x3E, 0xB3, 0x4D,
                                      0x39, 0x7D, 0xBE, 0x7B, 0x37, 0x40,
                                      0x8F, 0x72, 0x13, 0x6A, 0xCB, 0x08,
                                      0x79, 0xFE, 0x61, 0xC7, 0x18, 0xA3,
                                      0x7F, 0x51, 0x54, 0xB5, 0x07, 0x8A,
                                      0x76, 0x49, 0xFB, 0x3D, 0x4F, 0xB4,
                                      0xC4, 0x81, 0xE0, 0x10, 0x62, 0xC5,
                                      0x24, 0x1F, 0x22, 0x9F, 0xA5, 0x80,
                                      0x42, 0x33, 0x68, 0xDD, 0x51, 0x09,
                                      0x0D, 0xBF, 0x25, 0x35, 0x1F, 0x0C,
                                      0x58, 0x00, 0xDE, 0x05, 0xB9, 0x2B,
                                      0xA6, 0xA9 };

/*
  160-bit q

  Schnorr subgroup order q = ord(g); q | (p-1)

  */
const BYTE FAR_BSS subgroupOrderTestKEA[] = { 0x97, 0xad, 0x85, 0xfd, 0x2b,
                                              0x37, 0x1e, 0xd0, 0x69, 0x81,
                                              0x8a, 0xb3, 0xc6, 0xee, 0x87,
                                              0x73, 0xd9, 0xdb, 0x02, 0x9d };

/*
  1024-bit g

  base element for DH

  */
const BYTE FAR_BSS baseTestKEA[] = { 0x59, 0x5d, 0x34, 0x43, 0xec, 0x89,
                                     0x7c, 0x82, 0x51, 0xe5, 0xfa, 0x9d,
                                     0x02, 0xab, 0x8b, 0x75, 0xc0, 0xfc,
                                     0x57, 0xb0, 0x96, 0x9f, 0x88, 0x0d,
                                     0xa3, 0x66, 0xa1, 0x00, 0x01, 0x91,
                                     0x2a, 0x01, 0x96, 0xbc, 0xb8, 0x1c,
                                     0x41, 0xac, 0x84, 0x85, 0x03, 0x1a,
                                     0xc5, 0x98, 0xb5, 0x48, 0x1e, 0xae,
                                     0x27, 0x26, 0xb7, 0x19, 0xd8, 0xd9,
                                     0x91, 0x5a, 0x61, 0x05, 0x97, 0x34,
                                     0x72, 0x38, 0x6c, 0x0a, 0x6a, 0x2c,
                                     0x73, 0x2c, 0xd6, 0x70, 0x0d, 0x34,
                                     0x1f, 0x54, 0xbf, 0x28, 0xd1, 0x2d,
                                     0x69, 0x2d, 0xe2, 0xfa, 0x05, 0xf5,
                                     0x5e, 0x89, 0x8c, 0x2e, 0x20, 0xbb,
                                     0x8a, 0x26, 0x02, 0xdb, 0x1b, 0xa0,
                                     0x7d, 0xe6, 0x72, 0xe3, 0xb9, 0x6d,
                                     0x9a, 0xc2, 0x9a, 0x18, 0x84, 0x50,
                                     0x63, 0xd9, 0x18, 0xc3, 0x2e, 0xd7,
                                     0x12, 0x66, 0xb7, 0x83, 0x31, 0x1a,
                                     0x0a, 0x8d, 0x08, 0xac, 0x48, 0x7b,
                                     0xea, 0x44 };

/*
  160-bit ra

  ephemeral private exponent

  */
const BYTE FAR_BSS raTestKEA[] = { 0x62, 0x01, 0xdd, 0x56, 0x23, 0x7c, 0x22,
                                   0x8a, 0x3f, 0x54, 0xbc, 0x7e, 0x79, 0x4b,
                                   0xdf, 0x32, 0x41, 0xc6, 0x7e, 0xa6 };

/*
  160-bit xa

  long term private exponent

  */
const BYTE FAR_BSS xaTestKEA[] = { 0x62, 0x31, 0x9a, 0xc4, 0x7d, 0xe1, 0x45,
                                   0x18, 0x0a, 0xbd, 0x32, 0x2c, 0x59, 0xe2,
                                   0xb6, 0x00, 0x27, 0x81, 0xe4, 0x94 };

/*
  1024-bit Ya

  long term public key

  */
const BYTE FAR_BSS YaTestKEA[] = { 0x2d, 0x29, 0xec, 0xd0, 0x2e, 0x34, 0x97,
                                   0xa6, 0x72, 0x22, 0xd8, 0xde, 0xbc, 0x28,
                                   0x61, 0x31, 0xd1, 0x49, 0xf4, 0x58, 0x1b,
                                   0x3e, 0x58, 0x6d, 0x01, 0x51, 0x02, 0x4c,
                                   0x02, 0xe8, 0xb2, 0x3d, 0xa0, 0x9a, 0x43,
                                   0x0e, 0x2c, 0xa5, 0xed, 0x1a, 0x4b, 0x2d,
                                   0x77, 0x25, 0x62, 0x31, 0x6e, 0x4d, 0x28,
                                   0x04, 0xd2, 0x26, 0x78, 0x82, 0x84, 0xed,
                                   0x65, 0x5c, 0xf5, 0x46, 0x10, 0xd3, 0x8f,
                                   0x66, 0xfa, 0xb1, 0xa0, 0xa2, 0xe2, 0xd3,
                                   0xc6, 0x61, 0x44, 0x01, 0x90, 0x1d, 0x97,
                                   0x58, 0xd5, 0x66, 0x72, 0x2a, 0xff, 0x1f,
                                   0x73, 0x4b, 0x2a, 0xdb, 0xd2, 0xb6, 0x7f,
                                   0x13, 0x00, 0xce, 0x45, 0x5f, 0x00, 0x96,
                                   0x8c, 0xa7, 0x91, 0xa8, 0x76, 0x78, 0x67,
                                   0x36, 0x3d, 0x7d, 0x49, 0xee, 0x74, 0xa2,
                                   0x8d, 0xc3, 0x49, 0xd9, 0xfd, 0xfd, 0xb9,
                                   0x6b, 0x01, 0xf0, 0xfc, 0x1f, 0x06, 0x90,
                                   0xec, 0x96 };

/*
  160-bit xb

  long term private exponent

  */
const BYTE FAR_BSS xbTestKEA[] = { 0x63, 0xde, 0xcd, 0xad, 0x44, 0x87, 0xeb,
                                   0x71, 0x31, 0xdf, 0xf4, 0xf5, 0x1c, 0xfb,
                                   0xae, 0x39, 0x44, 0x6b, 0x9b, 0x3d };

/*
  160-bit rb

  ephemeral private exponent

  */
const BYTE FAR_BSS rbTestKEA[] = { 0x52, 0xbf, 0xa1, 0xd7, 0x2f, 0x1c, 0xf0,
                                   0xfb, 0x0f, 0xf6, 0xd5, 0xdf, 0x15, 0xfb,
                                   0x74, 0x83, 0x16, 0x7e, 0xb0, 0xe7 };

/*
  1024-bit Yb

  long term public key

  */
const BYTE FAR_BSS YbTestKEA[] = { 0x77, 0x30, 0xd4, 0xbb, 0xf3, 0xa2, 0xef,
                                   0xdb, 0x21, 0x8e, 0x70, 0x41, 0x3e, 0x86,
                                   0x10, 0x20, 0x14, 0xce, 0xc0, 0x6c, 0x20,
                                   0x5f, 0x54, 0x19, 0x29, 0x3b, 0x65, 0xc6,
                                   0x9a, 0x97, 0x1e, 0x54, 0x55, 0xeb, 0x79,
                                   0xa0, 0xbd, 0xb9, 0x0a, 0xb2, 0x14, 0xc5,
                                   0x24, 0x0e, 0xde, 0x6c, 0xfd, 0xd5, 0x8c,
                                   0x7c, 0x19, 0xc5, 0x26, 0x9d, 0x57, 0xdf,
                                   0xf6, 0x0b, 0x61, 0xc1, 0xdb, 0x2f, 0xf6,
                                   0x48, 0x64, 0xbe, 0xe5, 0x19, 0x87, 0xf2,
                                   0x70, 0x03, 0x4b, 0xc3, 0x90, 0xad, 0x73,
                                   0x16, 0x82, 0x09, 0x5e, 0x42, 0x60, 0x8c,
                                   0x3d, 0x79, 0x87, 0xf9, 0x64, 0x9f, 0xbf,
                                   0x71, 0x68, 0x87, 0x63, 0x3e, 0xb5, 0x74,
                                   0xb3, 0x9c, 0xc7, 0x3d, 0xf8, 0x99, 0x51,
                                   0xfc, 0x1b, 0xd6, 0xd3, 0x88, 0x9d, 0x48,
                                   0xfe, 0x22, 0x44, 0xb8, 0x29, 0xaf, 0xd4,
                                   0x05, 0x06, 0xab, 0x92, 0x21, 0xba, 0x56,
                                   0x2c, 0x07 };

/*
  Computed by A:

  */

/*
  1024-bit Ra

  ephemeral public key

  */
const BYTE FAR_BSS RaTestKEA[] = { 0x97, 0xc1, 0xfd, 0x8a, 0x69, 0xfc, 0x8f,
                                   0x34, 0xa7, 0x4c, 0x7e, 0xc3, 0xc1, 0xab,
                                   0x17, 0x6a, 0xb9, 0x1f, 0xa0, 0xea, 0xd0,
                                   0xe6, 0xb0, 0x97, 0x06, 0xae, 0x07, 0xa1,
                                   0xfb, 0xf8, 0xd0, 0xa6, 0x67, 0x03, 0x2e,
                                   0xa4, 0x79, 0x80, 0x82, 0xb8, 0xca, 0xea,
                                   0x82, 0x7b, 0x4f, 0x60, 0x4b, 0x71, 0xe6,
                                   0xc2, 0x44, 0x69, 0x21, 0x13, 0x63, 0xea,
                                   0x4b, 0xd2, 0x12, 0x2f, 0x4a, 0xa6, 0xaf,
                                   0xb9, 0x48, 0x57, 0xff, 0x06, 0x9d, 0xb0,
                                   0x37, 0x01, 0x2b, 0x28, 0x90, 0x57, 0xb4,
                                   0x85, 0x5e, 0x70, 0xf8, 0xf7, 0xac, 0x4f,
                                   0x92, 0xfa, 0x1f, 0xe7, 0x6c, 0x2a, 0x5c,
                                   0x82, 0x78, 0x1e, 0xe6, 0x11, 0x1c, 0x1f,
                                   0xbd, 0xf7, 0xa6, 0xeb, 0x9d, 0xc3, 0x59,
                                   0xa8, 0xfc, 0xa0, 0xb6, 0x32, 0xef, 0x3a,
                                   0x2a, 0xf8, 0x2e, 0x52, 0xc0, 0xa7, 0xf6,
                                   0xa6, 0xa2, 0xc9, 0x61, 0xea, 0xfc, 0x67,
                                   0xf4, 0x18 };

/*
  Computed by B:

  */

/*
  1024-bit Rb

  ephemeral public key

  */
const BYTE FAR_BSS RbTestKEA[] = { 0x91, 0xf6, 0x18, 0x08, 0x38, 0xf0, 0x3d,
                                   0x5b, 0x6b, 0xe5, 0x38, 0xff, 0x6e, 0x0b,
                                   0xf3, 0xcb, 0x9d, 0x8a, 0xfb, 0xbe, 0xef,
                                   0x19, 0x93, 0x34, 0xb3, 0x89, 0x70, 0x8b,
                                   0xb0, 0xc8, 0x48, 0xda, 0x86, 0x0f, 0x0f,
                                   0x27, 0x62, 0xcc, 0x94, 0xa8, 0xe4, 0x96,
                                   0xf8, 0xfc, 0x94, 0x94, 0x55, 0x38, 0xcf,
                                   0x6f, 0x17, 0x19, 0x57, 0xce, 0xe4, 0xf1,
                                   0xe2, 0xec, 0xa2, 0xba, 0xdd, 0xb3, 0x40,
                                   0xda, 0xf4, 0x06, 0xe6, 0x36, 0xbb, 0xc6,
                                   0x36, 0x8e, 0x46, 0x58, 0xfb, 0xf0, 0x1a,
                                   0x41, 0xcb, 0xef, 0x5a, 0xdb, 0x40, 0x86,
                                   0x42, 0xd0, 0x3c, 0xec, 0x4e, 0x85, 0x92,
                                   0x0c, 0x8e, 0x75, 0x30, 0xbd, 0xe2, 0xb7,
                                   0x8c, 0xb8, 0x7c, 0xba, 0xe3, 0x64, 0x31,
                                   0xde, 0x37, 0x3c, 0xd2, 0xeb, 0xaf, 0x29,
                                   0xd8, 0x41, 0x29, 0x32, 0x85, 0x50, 0xdd,
                                   0x8c, 0xf3, 0x3e, 0x03, 0xc2, 0x1a, 0x50,
                                   0x56, 0xa0 };

/*
  Results for user A:

  */

/*
  1024-bit uab

  shared DH key

  */
const BYTE FAR_BSS uabTestKEA[] = { 0x15, 0x85, 0xdb, 0xba, 0xc0, 0x6b, 0x96,
                                    0x3d, 0x6e, 0xf5, 0xa3, 0x0e, 0x5c, 0x40,
                                    0x22, 0x0b, 0x76, 0xfe, 0x05, 0x28, 0x66,
                                    0x0b, 0xe3, 0x1a, 0xc4, 0x96, 0xd1, 0xcb,
                                    0x08, 0x83, 0xba, 0x8e, 0x5a, 0x03, 0x31,
                                    0xe9, 0xce, 0x3f, 0xe3, 0x82, 0xf4, 0x7a,
                                    0x35, 0x3c, 0xed, 0xc6, 0x89, 0x6d, 0xfd,
                                    0xb4, 0xc0, 0xb5, 0x67, 0xaa, 0xfd, 0x72,
                                    0x4b, 0xa0, 0xff, 0x6f, 0x2c, 0x0f, 0xa4,
                                    0x28, 0xfc, 0xb0, 0x7a, 0x32, 0xbf, 0x6f,
                                    0xb8, 0x8e, 0x22, 0xc5, 0xca, 0x47, 0x7c,
                                    0x9b, 0xb9, 0xcd, 0x88, 0x2d, 0xa4, 0xf5,
                                    0x4c, 0xc5, 0x79, 0x80, 0xc1, 0x74, 0x35,
                                    0x2f, 0x13, 0x43, 0x46, 0x23, 0xce, 0x3d,
                                    0xf2, 0xd4, 0x14, 0xa9, 0xe0, 0xfb, 0x7a,
                                    0x90, 0x5f, 0xe8, 0x4a, 0xb2, 0x82, 0xd5,
                                    0xe7, 0x6e, 0x70, 0x3a, 0x55, 0xda, 0xbb,
                                    0x38, 0x27, 0xc2, 0x97, 0x9f, 0x08, 0xea,
                                    0x28, 0xc8 };

/*
  1024-bit tab

  shared DH key

  */
const BYTE FAR_BSS tabTestKEA[] = { 0x80, 0x32, 0xeb, 0x2c, 0xb6, 0x75, 0x34,
                                    0xa9, 0xc5, 0xfa, 0xf6, 0xbe, 0xa1, 0xeb,
                                    0x6e, 0xf1, 0xde, 0x0d, 0x3f, 0x48, 0xc8,
                                    0x6b, 0xe2, 0x40, 0x8f, 0x80, 0x7e, 0x65,
                                    0x86, 0x22, 0xb9, 0xf3, 0x87, 0xe0, 0xf5,
                                    0x0f, 0xa5, 0x86, 0x8b, 0xf5, 0x29, 0xff,
                                    0x00, 0x8d, 0x3a, 0xd5, 0x5e, 0x9c, 0x43,
                                    0x66, 0xba, 0xd4, 0xae, 0x41, 0x90, 0xce,
                                    0xbc, 0x3a, 0xe5, 0x6f, 0x34, 0xbf, 0x70,
                                    0xb6, 0x3c, 0xa0, 0x21, 0xdd, 0x56, 0x30,
                                    0x05, 0xdb, 0xbc, 0x7e, 0x62, 0xbb, 0xcc,
                                    0xc9, 0x12, 0x7a, 0x36, 0x03, 0xbf, 0x00,
                                    0xbe, 0x8f, 0xce, 0x9b, 0xf4, 0x6b, 0xf5,
                                    0x38, 0x86, 0xc4, 0xa7, 0x61, 0x4b, 0x43,
                                    0xad, 0xfe, 0x72, 0x82, 0xef, 0xe4, 0xf9,
                                    0xc1, 0x46, 0xb7, 0x1e, 0x9f, 0x89, 0xd6,
                                    0x2b, 0xd3, 0xc7, 0xed, 0x7d, 0x12, 0x77,
                                    0x19, 0xeb, 0xf0, 0xe0, 0xf8, 0x79, 0xe0,
                                    0xd0, 0xd9 };

/*
  1024-bit w

  sum of shared DH keys

  */
const BYTE FAR_BSS wTestKEA[] = { 0x95, 0xb8, 0xc6, 0xe7, 0x76, 0xe0, 0xca,
                                  0xe7, 0x34, 0xf0, 0x99, 0xcc, 0xfe, 0x2b,
                                  0x90, 0xfd, 0x55, 0x0b, 0x44, 0x71, 0x2e,
                                  0x77, 0xc5, 0x5b, 0x54, 0x17, 0x50, 0x31,
                                  0x8e, 0xa6, 0x74, 0x81, 0xe1, 0xe4, 0x26,
                                  0xf9, 0x73, 0xc6, 0x6f, 0x78, 0x1e, 0x79,
                                  0x35, 0xca, 0x28, 0x9b, 0xe8, 0x0a, 0x41,
                                  0x1b, 0x7b, 0x8a, 0x15, 0xec, 0x8e, 0x41,
                                  0x07, 0xdb, 0xe4, 0xde, 0x60, 0xcf, 0x14,
                                  0xdf, 0x39, 0x50, 0x9c, 0x10, 0x15, 0x9f,
                                  0xbe, 0x69, 0xdf, 0x44, 0x2d, 0x03, 0x49,
                                  0x64, 0xcc, 0x47, 0xbe, 0x31, 0x63, 0xf6,
                                  0x0b, 0x55, 0x48, 0x1c, 0xb5, 0xe0, 0x2a,
                                  0x67, 0x9a, 0x07, 0xed, 0x85, 0x19, 0x81,
                                  0xa0, 0xd2, 0x87, 0x2c, 0xd0, 0xe0, 0x74,
                                  0x51, 0xa6, 0x9f, 0x69, 0x52, 0x0c, 0xac,
                                  0x13, 0x42, 0x38, 0x27, 0xd2, 0xed, 0x32,
                                  0x52, 0x13, 0xb3, 0x78, 0x97, 0x82, 0xca,
                                  0xf9, 0xa1 };

/*
  v1 = {0x95, 0xb8, 0xc6, 0xe7, 0x76, 0xe0, 0xca, 0xe7, 0x34, 0xf0,
  0xXX, 0xXX}

  v2 = {0x99, 0xcc, 0xfe, 0x2b, 0x90, 0xfd, 0x55, 0x0b, 0x44, 0x71,
  0xXX, 0xXX}

  v1 XOR pad = {0xe7, 0x49, 0x6e, 0x99, 0xe4, 0x62, 0x8b, 0x7f, 0x9f,
  0xfb, 0xXX, 0xXX}

  */

/*
  80-bit Skipjack key for user A

  */
const BYTE FAR_BSS sjkeyTestKEA[] = { 0x74, 0x08, 0x39, 0xde, 0xe8, 0x33,
                                      0xad, 0xd4, 0x6b, 0x41 };

/*
  Results for user B:
  (see above)

  */

/* int keaInitKey( CRYPT_INFO *cryptInfo, BYTE *buffer, int noBytes ); */
/* int keaEncrypt( CRYPT_INFO *cryptInfo, BYTE *buffer, int noBytes ); */
int keaDecrypt( CRYPT_INFO *cryptInfo, BYTE *bufferT, BYTE *bufferU,
                BYTE *bufferSJK );

int keaSelfTest( void )
	{
	CRYPT_INFO cryptInfo1, cryptInfo2, cryptInfo3, cryptInfo4;
	CRYPT_PKCINFO_DLP *dhKey;
	CAPABILITY_INFO capabilityInfo = { CRYPT_ALGO_KEA, CRYPT_MODE_PKC, 
									0, NULL, NULL, 64, 128, 1024, 0, 
									NULL, NULL, NULL, NULL, NULL, NULL, NULL,
									NULL, NULL, NULL, NULL, CRYPT_ERROR };
	BYTE buffer1[ 128 ], buffer2[ 128 ], buffer3[ 128 ], buffer4[ 128 ];
	BYTE buffer5[ 10 ];
	BIGNUM *yr, *yrone, *p, *q;
	BN_CTX *bnCTX;
	int status = CRYPT_OK;

	/* Set up the key components */
	if( ( dhKey = ( CRYPT_PKCINFO_DLP * ) malloc( sizeof( CRYPT_PKCINFO_DLP ) ) ) == NULL )
		return( CRYPT_ERROR_MEMORY );
	cryptInitComponents( dhKey, CRYPT_KEYTYPE_PRIVATE );
	cryptSetComponent( dhKey->p, primeTestKEA, 1024 );
	cryptSetComponent( dhKey->g, baseTestKEA, 1024 );

	/* certified public key Y of each user */
	memset( &cryptInfo1, 0, sizeof( CRYPT_INFO ) );
	cryptInfo1.ctxPKC.param1 = BN_new();
	cryptInfo1.ctxPKC.param2 = BN_new();
	cryptInfo1.ctxPKC.param3 = BN_new();
	cryptInfo1.capabilityInfo = &capabilityInfo;
	memset( &cryptInfo2, 0, sizeof( CRYPT_INFO ) );
	cryptInfo2.ctxPKC.param1 = BN_new();
	cryptInfo2.ctxPKC.param2 = BN_new();
	cryptInfo2.ctxPKC.param3 = BN_new();
	cryptInfo2.capabilityInfo = &capabilityInfo;

	/* ephemeral public key R of each user */
	memset( &cryptInfo3, 0, sizeof( CRYPT_INFO ) );
	cryptInfo3.ctxPKC.param1 = BN_new();
	cryptInfo3.ctxPKC.param2 = BN_new();
	cryptInfo3.ctxPKC.param3 = BN_new();
	cryptInfo3.capabilityInfo = &capabilityInfo;
	memset( &cryptInfo4, 0, sizeof( CRYPT_INFO ) );
	cryptInfo4.ctxPKC.param1 = BN_new();
	cryptInfo4.ctxPKC.param2 = BN_new();
	cryptInfo4.ctxPKC.param3 = BN_new();
	cryptInfo4.capabilityInfo = &capabilityInfo;

	/* Load long term private keys x of each user */
	memset( buffer1, 0, 128 );
	memcpy( buffer1, xaTestKEA, 20 );
	memset( buffer2, 0, 128 );
	memcpy( buffer2, xbTestKEA, 20 );

	/* Exchange of certificates for DH public keys Y (step a.) */
	if( dhInitKey( &cryptInfo1 ) != CRYPT_OK ||
	    dhInitKey( &cryptInfo2 ) != CRYPT_OK ||
		cryptStatusError( dhEncrypt( &cryptInfo1, buffer1, 128 ) ) ||
		cryptStatusError( dhEncrypt( &cryptInfo2, buffer2, 128 ) ) )
		status = CRYPT_ERROR;

	/* Certificate validation would go here (step b.)
		see draft-ietf-pkix-ipki-kea-02.txt */

	/* Load ephemeral private keys r of each user */
	memset( buffer3, 0, 128 );
	memcpy( buffer3, raTestKEA, 20 );
	memset( buffer4, 0, 128 );
	memcpy( buffer4, rbTestKEA, 20 );

	/* Exchange of ephemeral public keys R (step c.) */
	if( dhInitKey( &cryptInfo3 ) != CRYPT_OK ||
		dhInitKey( &cryptInfo4 ) != CRYPT_OK ||
		cryptStatusError( dhEncrypt( &cryptInfo3, buffer3, 128 ) ) ||
		cryptStatusError( dhEncrypt( &cryptInfo4, buffer4, 128 ) ) )
		status = CRYPT_ERROR;

	/* Check that received public keys are in order q subgroup(s)
	   (step d.) */
	yr = BN_new();
	yrone = BN_new();
	q = BN_new();
	p = BN_new();
	BN_bin2bn( ( BYTE * ) subgroupOrderTestKEA, 20, q );
	BN_bin2bn( dhKey->p, 128, p );
	BN_bin2bn( buffer1, 128, yr );
	BN_mod_exp( yrone, yr, q, p, bnCTX );
	if( BN_cmp( yrone, BN_value_one() ) != 0 )
		status = CRYPT_ERROR;
	BN_bin2bn( buffer2, 128, yr );
	BN_mod_exp( yrone, yr, q, p, bnCTX );
	if( BN_cmp( yrone, BN_value_one() ) != 0 )
		status = CRYPT_ERROR;
	BN_bin2bn( buffer3, 128, yr );
	BN_mod_exp( yrone, yr, q, p, bnCTX );
	if( BN_cmp( yrone, BN_value_one() ) != 0 )
		status = CRYPT_ERROR;
	BN_bin2bn( buffer4, 128, yr );
	BN_mod_exp( yrone, yr, q, p, bnCTX );
	if( BN_cmp( yrone, BN_value_one() ) != 0 )
		status = CRYPT_ERROR;
	BN_clear_free( yr );
	BN_clear_free( yrone );
	BN_clear_free( q );

	/* Computation of shared keys tab, tba, uba, uab (steps e.,f.)
	   We also check that tab=tba and uba=uab */
	if( cryptStatusError( dhDecrypt( &cryptInfo3, buffer2,
									 CRYPT_USE_DEFAULT ) ) ||
		cryptStatusError( dhDecrypt( &cryptInfo2, buffer3,
									 CRYPT_USE_DEFAULT ) ) ||
		cryptStatusError( dhDecrypt( &cryptInfo4, buffer1,
									 CRYPT_USE_DEFAULT ) ) ||
		cryptStatusError( dhDecrypt( &cryptInfo1, buffer4,
									 CRYPT_USE_DEFAULT ) ) ||
		memcmp( buffer2, buffer3, 128 ) ||
		memcmp( buffer1, buffer4, 128 ) )
		status = CRYPT_ERROR;

	/* derive the Skipjack key from t and u (steps g. to i.) */
	if( keaDecrypt( &cryptInfo1, buffer2, buffer1, buffer5 ) )
		status = CRYPT_ERROR;

	/* did we end up with the correct Skipjack key ? */
	if( memcmp( buffer5, sjkeyTestKEA, 10 ) )
		status = CRYPT_ERROR;

	/* Clean up */
	cryptDestroyComponents( dhKey );
	BN_clear_free( cryptInfo1.ctxPKC.param1 );
	BN_clear_free( cryptInfo1.ctxPKC.param2 );
	BN_clear_free( cryptInfo1.ctxPKC.param3 );
	zeroise( &cryptInfo1, sizeof( CRYPT_INFO ) );
	BN_clear_free( cryptInfo2.ctxPKC.param1 );
	BN_clear_free( cryptInfo2.ctxPKC.param2 );
	BN_clear_free( cryptInfo2.ctxPKC.param3 );
	zeroise( &cryptInfo2, sizeof( CRYPT_INFO ) );
	BN_clear_free( cryptInfo3.ctxPKC.param1 );
	BN_clear_free( cryptInfo3.ctxPKC.param2 );
	BN_clear_free( cryptInfo3.ctxPKC.param3 );
	zeroise( &cryptInfo3, sizeof( CRYPT_INFO ) );
	BN_clear_free( cryptInfo4.ctxPKC.param1 );
	BN_clear_free( cryptInfo4.ctxPKC.param2 );
	BN_clear_free( cryptInfo4.ctxPKC.param3 );
	zeroise( &cryptInfo4, sizeof( CRYPT_INFO ) );
	free( dhKey );

	return( status );
	}

/* steps g. through i. of KEA
   receive shared DH keys t and u in 2 buffers,
   compute Skipjack key and store in the 3rd buffer */

int keaDecrypt( CRYPT_INFO *cryptInfo, BYTE *bufferT, BYTE *bufferU,
				BYTE *bufferSJK )
	{
	BIGNUM *bnT, *bnU;
	BN_CTX *bnCTX;
	const BYTE pad[] = { 0x72, 0xF1, 0xA8, 0x7E, 0x92, 0x82, 0x41, 0x98, 0xAB, 0x0B };
	int status = 0;

	if( ( bnCTX = BN_CTX_new() ) == NULL )
		return( CRYPT_ERROR_MEMORY );

	/* step g. -- Move t and u from the buffers into bignums */
	bnT = BN_new();
	bnU = BN_new();
	BN_bin2bn( bufferT, 128, bnT );
	BN_bin2bn( bufferU, 128, bnU );
	zeroise( bufferT, 128 );	/* Clear buffer while data is in bignum */
	zeroise( bufferU, 128 );	/* ditto */

	/* set w = t + u mod p; we overwrite t with w */
	if( BN_add( bnT, bnT, bnU ) != 0 )
		status = CRYPT_ERROR_FAILED;
	BN_clear_free( bnU );
	if( BN_mod( bnT, bnT, cryptInfo->ctxPKC.dlpParam_p, bnCTX ) != 0 )
		status = CRYPT_ERROR_FAILED;

	/* abort if w == 0 */
	if( BN_is_zero( bnT ) )
		status = CRYPT_ERROR_FAILED;

	/* step h. -- Extract v_1 and v_2 from w;
		v_1 is the 80 MSB's of w and
		v_2 is the 80 next-most-significant bits of w, each big-endian */
	BN_rshift( bnT, bnT, (1024 - (80 + 80)) );
	BN_bn2bin( bnT, bufferT );
	BN_clear_free( bnT );

	/* XOR the pad into v_1 */
	bufferT[ 0 ] ^= pad[ 0 ];
	bufferT[ 1 ] ^= pad[ 1 ];
	bufferT[ 2 ] ^= pad[ 2 ];
	bufferT[ 3 ] ^= pad[ 3 ];
	bufferT[ 4 ] ^= pad[ 4 ];
	bufferT[ 5 ] ^= pad[ 5 ];
	bufferT[ 6 ] ^= pad[ 6 ];
	bufferT[ 7 ] ^= pad[ 7 ];
	bufferT[ 8 ] ^= pad[ 8 ];
	bufferT[ 9 ] ^= pad[ 9 ];

	/* Skipjack-encrypt the 64 MSB's of v_2 with v_1 XOR pad */
	skipjackEncrypt( (bufferT + 10), bufferT );

	/* XOR the 16 MSB's of the resulting ciphertext into the 16 LSB's of v_2 */
	bufferT[ 18 ] ^= bufferT[ 10 ];
	bufferT[ 19 ] ^= bufferT[ 11 ];

	/* Skipjack-encrypt the previous ciphertext with the same key as before;
	   the 80 bits starting at bufferT + 10 then contain the KEA Key */
	skipjackEncrypt( (bufferT + 10), bufferT );
	memcpy( bufferSJK, (bufferT + 10), 10 );
	zeroise( bufferT, 128 );

	return( status );
	}
